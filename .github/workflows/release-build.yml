name: Release Build

on:
  push:
    branches: ['release/*']
  workflow_dispatch:

permissions:
  contents: write
  id-token: write
  attestations: write

concurrency:
  group: release-build-${{ github.ref }}
  cancel-in-progress: true

env:
  SOLUTION_FILE: ClipSave.slnx
  APP_PROJECT: src/ClipSave/ClipSave.csproj

jobs:
  build_and_publish:
    runs-on: windows-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        global-json-file: global.json

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.slnx') }}
        restore-keys: ${{ runner.os }}-nuget-

    - name: Guard release branch
      shell: pwsh
      run: |
        $branch = "${{ github.ref_name }}"
        if ($branch -notmatch '^release/\d+\.\d+$') {
          Write-Error "Release Build can run only on release/X.Y branches. Current ref: $branch"
          exit 1
        }

    - name: Resolve release build versions
      id: version
      shell: pwsh
      run: |
        $branch = "${{ github.ref_name }}"
        [xml]$props = Get-Content Directory.Build.props
        $version = $props.Project.PropertyGroup.Version
        $match = [regex]::Match($version, '^(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)$')
        if (-not $match.Success) {
          Write-Error "Invalid version format in Directory.Build.props (expected X.Y.Z): $version"
          exit 1
        }
        $branchMatch = [regex]::Match($branch, '^release/(?<major>\d+)\.(?<minor>\d+)$')
        if (-not $branchMatch.Success) {
          Write-Error "Invalid release branch format for channel tag resolution: $branch"
          exit 1
        }
        $coreVersion = "$($match.Groups['major'].Value).$($match.Groups['minor'].Value).$($match.Groups['patch'].Value)"
        $releaseLine = "$($branchMatch.Groups['major'].Value).$($branchMatch.Groups['minor'].Value)"
        $releaseChannelTag = "release-$releaseLine-latest"
        $shortSha = "${{ github.sha }}".Substring(0, 7)
        $segments = @(
          [int]$match.Groups['major'].Value,
          [int]$match.Groups['minor'].Value,
          [int]$match.Groups['patch'].Value,
          0
        )
        if ($segments | Where-Object { $_ -lt 0 -or $_ -gt 65535 }) {
          Write-Error "MSIX version segments must be within 0..65535. Resolved segments: $($segments -join '.')"
          exit 1
        }

        $assemblyVersion = "$($match.Groups['major'].Value).$($match.Groups['minor'].Value).0.0"
        $fileVersion = "$coreVersion.0"
        $informationalVersion = "$coreVersion+sha.$shortSha"
        $msixVersion = "$coreVersion.0"

        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "ASSEMBLY_VERSION=$assemblyVersion" >> $env:GITHUB_OUTPUT
        echo "FILE_VERSION=$fileVersion" >> $env:GITHUB_OUTPUT
        echo "INFORMATIONAL_VERSION=$informationalVersion" >> $env:GITHUB_OUTPUT
        echo "MSIX_VERSION=$msixVersion" >> $env:GITHUB_OUTPUT
        echo "RELEASE_CHANNEL_TAG=$releaseChannelTag" >> $env:GITHUB_OUTPUT
        echo "Version: $version"
        echo "AssemblyVersion: $assemblyVersion"
        echo "FileVersion: $fileVersion"
        echo "InformationalVersion: $informationalVersion"
        echo "MSIX version: $msixVersion"
        echo "Release channel tag: $releaseChannelTag"

    - name: Validate version
      shell: pwsh
      run: ./scripts/assert-version-policy.ps1 -BranchName "${{ github.ref_name }}"

    - name: Restore
      run: dotnet restore ${{ env.SOLUTION_FILE }}

    - name: Security checks
      shell: pwsh
      run: ./scripts/run-security-checks.ps1 -Configuration Release -NoRestore

    - name: Build app
      shell: pwsh
      run: |
        dotnet build ${{ env.APP_PROJECT }} --configuration Release --no-restore `
          /p:Version="${{ steps.version.outputs.VERSION }}" `
          /p:AssemblyVersion="${{ steps.version.outputs.ASSEMBLY_VERSION }}" `
          /p:FileVersion="${{ steps.version.outputs.FILE_VERSION }}" `
          /p:InformationalVersion="${{ steps.version.outputs.INFORMATIONAL_VERSION }}"

    - name: Test
      shell: pwsh
      run: ./scripts/run-tests.ps1 -Configuration Release -Verbosity normal

    # Desktop Bridge packaging restores/publishes the app as win-x86 internally.
    # Keep this even when package platform is AnyCPU, otherwise NETSDK1047 occurs.
    - name: Restore app assets for MSIX runtime
      run: dotnet restore ${{ env.APP_PROJECT }} --runtime win-x86

    - name: Set MSIX manifest version
      shell: pwsh
      run: |
        $manifestPath = "src/ClipSave.Package/Package.appxmanifest"
        [xml]$manifest = Get-Content $manifestPath
        $ns = New-Object System.Xml.XmlNamespaceManager($manifest.NameTable)
        $ns.AddNamespace("appx", "http://schemas.microsoft.com/appx/manifest/foundation/windows10")
        $identity = $manifest.SelectSingleNode("/appx:Package/appx:Identity", $ns)
        if (-not $identity) {
          throw "Identity node not found in $manifestPath"
        }
        $identity.SetAttribute("Version", "${{ steps.version.outputs.MSIX_VERSION }}")
        $manifest.Save($manifestPath)
        Write-Host "Updated Package.appxmanifest version to ${{ steps.version.outputs.MSIX_VERSION }}"

    - name: Build unsigned MSIX
      shell: pwsh
      run: |
        msbuild src/ClipSave.Package/ClipSave.Package.wapproj `
          /p:Configuration=Release /p:Platform=AnyCPU `
          /p:Version="${{ steps.version.outputs.VERSION }}" `
          /p:AssemblyVersion="${{ steps.version.outputs.ASSEMBLY_VERSION }}" `
          /p:FileVersion="${{ steps.version.outputs.FILE_VERSION }}" `
          /p:InformationalVersion="${{ steps.version.outputs.INFORMATIONAL_VERSION }}" `
          /p:AppxPackageDir="${{ github.workspace }}/output/" `
          /p:AppxPackageVersion=${{ steps.version.outputs.MSIX_VERSION }} `
          /p:AppxBundleManifestVersion=${{ steps.version.outputs.MSIX_VERSION }} `
          /p:AppxManifestIdentityVersion=${{ steps.version.outputs.MSIX_VERSION }} `
          /p:AppxPackageSigningEnabled=false

    - name: Validate unsigned bundle version
      shell: pwsh
      run: |
        $outputDir = "${{ github.workspace }}/output"
        $expectedVersion = "${{ steps.version.outputs.MSIX_VERSION }}"
        $bundles = @(Get-ChildItem $outputDir -Recurse -File -Filter *.msixbundle)
        if ($bundles.Count -eq 0) {
          throw "No .msixbundle found under $outputDir"
        }
        if ($bundles.Count -ne 1) {
          $actual = ($bundles | Select-Object -ExpandProperty Name) -join ", "
          throw "Expected exactly one .msixbundle under $outputDir, found $($bundles.Count): $actual"
        }

        $bundle = $bundles[0]
        $pattern = "_$([regex]::Escape($expectedVersion))_"
        if ($bundle.Name -notmatch $pattern) {
          throw "Bundle filename does not contain expected version '$expectedVersion'. Found: $($bundle.Name)"
        }
        Write-Host "Unsigned bundle version validated: $($bundle.Name)"

    - name: Generate SHA256 checksums
      shell: pwsh
      run: |
        $outputDir = "${{ github.workspace }}/output"
        $bundles = @(Get-ChildItem $outputDir -Recurse -File -Filter *.msixbundle | Sort-Object FullName)
        if ($bundles.Count -eq 0) {
          throw "No .msixbundle found under $outputDir"
        }
        if ($bundles.Count -ne 1) {
          $actual = ($bundles | Select-Object -ExpandProperty FullName) -join ", "
          throw "Expected exactly one .msixbundle under $outputDir, found $($bundles.Count): $actual"
        }

        $bundle = $bundles[0]
        $checksumFile = Join-Path $outputDir "SHA256SUMS.txt"
        $relativePath = [System.IO.Path]::GetRelativePath($outputDir, $bundle.FullName).Replace('\', '/')
        $hash = (Get-FileHash -Path $bundle.FullName -Algorithm SHA256).Hash.ToLowerInvariant()
        $line = "$hash  $relativePath"

        Set-Content -Path $checksumFile -Value $line -Encoding ascii
        Write-Host "Generated checksum file: $checksumFile (subject: $relativePath)"

    - name: List package outputs
      shell: pwsh
      run: |
        Get-ChildItem "${{ github.workspace }}/output" -Recurse -File |
          Select-Object FullName, Length |
          Format-Table -AutoSize

    - name: Upload package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-package-${{ steps.version.outputs.VERSION }}
        path: |
          output/**/*.msixbundle
          output/SHA256SUMS.txt
        if-no-files-found: error
        retention-days: 30

    - name: Generate artifact attestation
      uses: actions/attest-build-provenance@96278af6caaf10aea03fd8d33a09a777ca52d62f # v3.2.0
      with:
        subject-path: |
          output/**/*.msixbundle
          output/SHA256SUMS.txt

    - name: Cleanup old release assets
      shell: pwsh
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        $tag = "${{ steps.version.outputs.RELEASE_CHANNEL_TAG }}"
        $repo = "${{ github.repository }}"

        $assetNames = gh release view $tag --repo $repo --json assets --jq '.assets[].name' 2>$null
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Release '$tag' not found. Skipping asset cleanup."
          exit 0
        }

        $assets = @($assetNames | Where-Object { $_ -and $_.Trim() -ne "" })
        if ($assets.Count -eq 0) {
          Write-Host "No assets to cleanup in '$tag'."
          exit 0
        }

        foreach ($asset in $assets) {
          gh release delete-asset $tag $asset --repo $repo --yes *> $null
          if ($LASTEXITCODE -ne 0) {
            throw "Failed to delete old asset '$asset' from release '$tag'."
          }
          Write-Host "Deleted old asset: $asset"
        }

    - name: Create Release Channel
      uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
      with:
        tag_name: ${{ steps.version.outputs.RELEASE_CHANNEL_TAG }}
        name: Release Candidate (${{ github.ref_name }})
        body: |
          ## Release Build (Unsigned)

          | Item | Value |
          |------|-------|
          | **Version** | `${{ steps.version.outputs.VERSION }}` |
          | **InformationalVersion** | `${{ steps.version.outputs.INFORMATIONAL_VERSION }}` |
          | **FileVersion** | `${{ steps.version.outputs.FILE_VERSION }}` |
          | **Package Version** | `${{ steps.version.outputs.MSIX_VERSION }}` |
          | **Signing** | `unsigned (Release channel policy)` |
          | **Checksum** | `SHA256SUMS.txt` |
          | **Provenance** | `GitHub Artifact Attestation` |
          | **Commit** | [`${{ github.sha }}`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |
          | **Build** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |

          > Unsigned package by channel policy. Verify `SHA256SUMS.txt` and GitHub Artifact Attestation (`gh attestation verify`) before use.
        files: |
          output/**/*.msixbundle
          output/SHA256SUMS.txt
        prerelease: false
        make_latest: false

    - name: Summary
      shell: pwsh
      run: |
        @'
        ## Release Build Complete (Unsigned)

        | Item | Value |
        |------|-------|
        | Version | `${{ steps.version.outputs.VERSION }}` |
        | InformationalVersion | `${{ steps.version.outputs.INFORMATIONAL_VERSION }}` |
        | FileVersion | `${{ steps.version.outputs.FILE_VERSION }}` |
        | Package Version | `${{ steps.version.outputs.MSIX_VERSION }}` |
        | Signing | `unsigned (Release channel policy)` |
        | Checksum | `SHA256SUMS.txt` |
        | Provenance | `GitHub Artifact Attestation` |
        | Artifact | `release-package-${{ steps.version.outputs.VERSION }}` |
        | Branch | `${{ github.ref_name }}` |
        | Build | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
        '@ >> $env:GITHUB_STEP_SUMMARY

    - name: Move release channel tag to current commit
      if: ${{ success() }}
      shell: pwsh
      env:
        GH_TOKEN: ${{ github.token }}
      run: ./scripts/update-floating-tag.ps1 -Repo "${{ github.repository }}" -Tag "${{ steps.version.outputs.RELEASE_CHANNEL_TAG }}" -Sha "${{ github.sha }}"

