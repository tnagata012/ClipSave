name: Release Build

on:
  push:
    branches: ['release/*']
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-build-${{ github.ref }}
  cancel-in-progress: true

env:
  DOTNET_VERSION: '10.0.x'
  SOLUTION_FILE: ClipSave.slnx
  APP_PROJECT: src/ClipSave/ClipSave.csproj

jobs:
  build_and_publish:
    runs-on: windows-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.slnx') }}
        restore-keys: ${{ runner.os }}-nuget-

    - name: Guard release branch
      shell: pwsh
      run: |
        $branch = "${{ github.ref_name }}"
        if ($branch -notmatch '^release/\d+\.\d+$') {
          Write-Error "Release Build can run only on release/X.Y branches. Current ref: $branch"
          exit 1
        }

    - name: Resolve release build versions
      id: version
      shell: pwsh
      run: |
        [xml]$props = Get-Content Directory.Build.props
        $version = $props.Project.PropertyGroup.Version
        $match = [regex]::Match($version, '^(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)$')
        if (-not $match.Success) {
          Write-Error "Invalid version format in Directory.Build.props (expected X.Y.Z): $version"
          exit 1
        }
        $coreVersion = "$($match.Groups['major'].Value).$($match.Groups['minor'].Value).$($match.Groups['patch'].Value)"
        $shortSha = "${{ github.sha }}".Substring(0, 7)
        $segments = @(
          [int]$match.Groups['major'].Value,
          [int]$match.Groups['minor'].Value,
          [int]$match.Groups['patch'].Value,
          0
        )
        if ($segments | Where-Object { $_ -lt 0 -or $_ -gt 65535 }) {
          Write-Error "MSIX version segments must be within 0..65535. Resolved segments: $($segments -join '.')"
          exit 1
        }

        $assemblyVersion = "$($match.Groups['major'].Value).$($match.Groups['minor'].Value).0.0"
        $fileVersion = "$coreVersion.0"
        $informationalVersion = "$coreVersion+sha.$shortSha"
        $msixVersion = "$coreVersion.0"

        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "ASSEMBLY_VERSION=$assemblyVersion" >> $env:GITHUB_OUTPUT
        echo "FILE_VERSION=$fileVersion" >> $env:GITHUB_OUTPUT
        echo "INFORMATIONAL_VERSION=$informationalVersion" >> $env:GITHUB_OUTPUT
        echo "MSIX_VERSION=$msixVersion" >> $env:GITHUB_OUTPUT
        echo "Version: $version"
        echo "AssemblyVersion: $assemblyVersion"
        echo "FileVersion: $fileVersion"
        echo "InformationalVersion: $informationalVersion"
        echo "MSIX version: $msixVersion"

    - name: Validate version
      shell: pwsh
      run: ./scripts/assert-version-policy.ps1 -BranchName "${{ github.ref_name }}"

    - name: Restore
      run: dotnet restore ${{ env.SOLUTION_FILE }}

    - name: Security checks
      shell: pwsh
      run: ./scripts/run-security-checks.ps1 -Configuration Release -NoRestore

    - name: Build app
      shell: pwsh
      run: |
        dotnet build ${{ env.APP_PROJECT }} --configuration Release --no-restore `
          /p:Version="${{ steps.version.outputs.VERSION }}" `
          /p:AssemblyVersion="${{ steps.version.outputs.ASSEMBLY_VERSION }}" `
          /p:FileVersion="${{ steps.version.outputs.FILE_VERSION }}" `
          /p:InformationalVersion="${{ steps.version.outputs.INFORMATIONAL_VERSION }}"

    - name: Test
      shell: pwsh
      run: ./scripts/run-tests.ps1 -Configuration Release -Verbosity normal

    # Desktop Bridge packaging restores/publishes the app as win-x86 internally.
    # Keep this even when package platform is AnyCPU, otherwise NETSDK1047 occurs.
    - name: Restore app assets for MSIX runtime
      run: dotnet restore ${{ env.APP_PROJECT }} --runtime win-x86

    - name: Set MSIX manifest version
      shell: pwsh
      run: |
        $manifestPath = "src/ClipSave.Package/Package.appxmanifest"
        [xml]$manifest = Get-Content $manifestPath
        $ns = New-Object System.Xml.XmlNamespaceManager($manifest.NameTable)
        $ns.AddNamespace("appx", "http://schemas.microsoft.com/appx/manifest/foundation/windows10")
        $identity = $manifest.SelectSingleNode("/appx:Package/appx:Identity", $ns)
        if (-not $identity) {
          throw "Identity node not found in $manifestPath"
        }
        $identity.SetAttribute("Version", "${{ steps.version.outputs.MSIX_VERSION }}")
        $manifest.Save($manifestPath)
        Write-Host "Updated Package.appxmanifest version to ${{ steps.version.outputs.MSIX_VERSION }}"

    - name: Build unsigned MSIX
      shell: pwsh
      run: |
        msbuild src/ClipSave.Package/ClipSave.Package.wapproj `
          /p:Configuration=Release /p:Platform=AnyCPU `
          /p:Version="${{ steps.version.outputs.VERSION }}" `
          /p:AssemblyVersion="${{ steps.version.outputs.ASSEMBLY_VERSION }}" `
          /p:FileVersion="${{ steps.version.outputs.FILE_VERSION }}" `
          /p:InformationalVersion="${{ steps.version.outputs.INFORMATIONAL_VERSION }}" `
          /p:AppxPackageDir="${{ github.workspace }}/output/" `
          /p:AppxPackageVersion=${{ steps.version.outputs.MSIX_VERSION }} `
          /p:AppxBundleManifestVersion=${{ steps.version.outputs.MSIX_VERSION }} `
          /p:AppxManifestIdentityVersion=${{ steps.version.outputs.MSIX_VERSION }} `
          /p:AppxPackageSigningEnabled=false

    - name: Validate unsigned bundle version
      shell: pwsh
      run: |
        $outputDir = "${{ github.workspace }}/output"
        $expectedVersion = "${{ steps.version.outputs.MSIX_VERSION }}"
        $bundles = Get-ChildItem $outputDir -Recurse -File -Filter *.msixbundle
        if (-not $bundles) {
          throw "No .msixbundle found under $outputDir"
        }

        $pattern = "_$([regex]::Escape($expectedVersion))_"
        $matched = $bundles | Where-Object { $_.Name -match $pattern }
        if (-not $matched) {
          $actual = ($bundles | Select-Object -ExpandProperty Name) -join ", "
          throw "Bundle filename does not contain expected version '$expectedVersion'. Found: $actual"
        }
        Write-Host "Unsigned bundle version validated: $($matched[0].Name)"

    - name: List package outputs
      shell: pwsh
      run: |
        Get-ChildItem "${{ github.workspace }}/output" -Recurse -File |
          Select-Object FullName, Length |
          Format-Table -AutoSize

    - name: Upload package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-package-${{ steps.version.outputs.VERSION }}
        path: output/**/*.msixbundle
        if-no-files-found: error
        retention-days: 30

    - name: Cleanup old release assets
      shell: pwsh
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        $tag = "release-latest"
        $repo = "${{ github.repository }}"

        $assetNames = gh release view $tag --repo $repo --json assets --jq '.assets[].name' 2>$null
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Release '$tag' not found. Skipping asset cleanup."
          exit 0
        }

        $assets = @($assetNames | Where-Object { $_ -and $_.Trim() -ne "" })
        if ($assets.Count -eq 0) {
          Write-Host "No assets to cleanup in '$tag'."
          exit 0
        }

        foreach ($asset in $assets) {
          gh release delete-asset $tag $asset --repo $repo --yes
          Write-Host "Deleted old asset: $asset"
        }

    - name: Create Release Channel
      uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
      with:
        tag_name: release-latest
        name: Release (Latest)
        body: |
          ## Release Build (Unsigned)

          | Item | Value |
          |------|-------|
          | **Version** | `${{ steps.version.outputs.VERSION }}` |
          | **InformationalVersion** | `${{ steps.version.outputs.INFORMATIONAL_VERSION }}` |
          | **FileVersion** | `${{ steps.version.outputs.FILE_VERSION }}` |
          | **Package Version** | `${{ steps.version.outputs.MSIX_VERSION }}` |
          | **Signing** | `disabled (temporary)` |
          | **Commit** | [`${{ github.sha }}`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |
          | **Build** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |

          > Unsigned package: signing workflow is temporarily deferred.
        files: |
          output/**/*.msixbundle
        prerelease: false
        make_latest: false

    - name: Summary
      shell: pwsh
      run: |
        @"
        ## Release Build Complete (Unsigned)

        | Item | Value |
        |------|-------|
        | Version | `${{ steps.version.outputs.VERSION }}` |
        | InformationalVersion | `${{ steps.version.outputs.INFORMATIONAL_VERSION }}` |
        | FileVersion | `${{ steps.version.outputs.FILE_VERSION }}` |
        | Package Version | `${{ steps.version.outputs.MSIX_VERSION }}` |
        | Signing | `disabled (temporary)` |
        | Artifact | `release-package-${{ steps.version.outputs.VERSION }}` |
        | Branch | `${{ github.ref_name }}` |
        | Build | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
        "@ >> $env:GITHUB_STEP_SUMMARY

